#!/usr/bin/env python

from __future__ import print_function

import rospy
from std_msgs.msg import String
import odrive
from odrive.enums import *
import time
import math

from ODrive_Interface_test.srv import *

positions = [0, 0, 0, 0, 0, 0]

print("Connecting...")
odrv0 = odrive.find_any(serial_number="206E3590524B")
print("Connected to ODrive 0")
odrv1 = odrive.find_any(serial_number="20573882304E")
print("Connected to ODrive 1")
odrv2 = odrive.find_any(serial_number="20843881304E")
print("Connected to ODrive 2")

def axis_velocity(req):
    print("Change velocity")

    if req.axis == 1:
        odrv1.axis0.controller.config.vel_limit = req.value
    if req.axis == 2:
        odrv0.axis0.controller.config.vel_limit = req.value
    if req.axis == 3:
        odrv0.axis1.controller.config.vel_limit = req.value
    if req.axis == 4:
        odrv2.axis0.controller.config.vel_limit = req.value
    if req.axis == 5:
        odrv2.axis1.controller.config.vel_limit = req.value
    if req.axis == 6:
        odrv1.axis1.controller.config.vel_limit = req.value

    return velocityResponse(True)

def drive_axis(req):
    print("Driving Axis " + str(req.axis) + ": " + str(req.value))
    
    if req.axis == 1:
        if abs(req.value-positions[0])*1024000/math.pi*300 > 20000:
            odrv1.axis0.controller.config.vel_limit = abs(req.value-positions[0])*1024000/math.pi*300
        else:
            odrv1.axis0.controller.config.vel_limit = 20000
        odrv1.axis0.controller.input_pos = req.value*1024000/math.pi
    if req.axis == 2:
        if abs(req.value-positions[1])*1024000/math.pi*300 > 20000:
            odrv0.axis0.controller.config.vel_limit = abs(req.value-positions[1])*1024000/math.pi*300
        else:
            odrv0.axis0.controller.config.vel_limit = 20000
        odrv0.axis0.controller.input_pos = req.value*(-1024000)/math.pi
    if req.axis == 3:
        if abs(req.value-positions[2])*204800/math.pi*300 > 20000:
            odrv0.axis1.controller.config.vel_limit = abs(req.value-positions[2])*204800/math.pi*300
        else:
            odrv0.axis1.controller.config.vel_limit = 20000
        odrv0.axis1.controller.input_pos = req.value*(-204800)/math.pi
    if req.axis == 4:
        if abs(req.value-positions[3])*204800/math.pi*300 > 20000:
            odrv2.axis0.controller.config.vel_limit = abs(req.value-positions[3])*204800/math.pi*300
        else:
            odrv2.axis0.controller.config.vel_limit = 20000
        odrv2.axis0.controller.input_pos = req.value*204800/math.pi
    if req.axis == 5:
        if abs(req.value-positions[4])*204800/math.pi*300 > 20000:
            odrv2.axis1.controller.config.vel_limit = abs(req.value-positions[4])*204800/math.pi*300
        else:
            odrv2.axis1.controller.config.vel_limit = 20000
        odrv2.axis1.controller.input_pos = req.value*204800/math.pi
    if req.axis == 6:
        if abs(req.value-positions[5])*204800/math.pi*300 > 20000:
            odrv1.axis1.controller.config.vel_limit = abs(req.value-positions[5])*204800/math.pi*300
        else:
            odrv1.axis1.controller.config.vel_limit = 20000
        odrv1.axis1.controller.input_pos = req.value*204800/math.pi

    positions[req.axis - 1] = req.value
    return driverResponse(True)

def axis_position(req):
    print("Axis Postition " + str(req.axis) + ": " + str(positions[req.axis - 1]))
    return feedbackResponse(positions[req.axis - 1])
    """
    if req.axis == 1:
        return feedbackResponse(int(round(odrv1.axis0.encoder.pos_estimate)))
    if req.axis == 2:
        return feedbackResponse(int(round(odrv0.axis0.encoder.pos_estimate)))
    if req.axis == 3:
        return feedbackResponse(int(round(odrv0.axis1.encoder.pos_estimate)))
    if req.axis == 4:
        return feedbackResponse(int(round(odrv2.axis0.encoder.pos_estimate)))
    if req.axis == 5:
        return feedbackResponse(int(round(odrv2.axis1.encoder.pos_estimate)))
    if req.axis == 6:
        return feedbackResponse(int(round(odrv1.axis1.encoder.pos_estimate)))
    """

def axis_requested_state(req):
    print("Axis requested_state")

    if req.axis == 1:
        if req.requested_state == 0:
            odrv1.axis0.requested_state = AXIS_STATE_FULL_CALIBRATION_SEQUENCE
            while odrv1.axis0.current_state != AXIS_STATE_IDLE:
                time.sleep(0.1)
            odrv1.axis0.requested_state = AXIS_STATE_CLOSED_LOOP_CONTROL
        else:
            odrv1.axis0.requested_state = req.requested_state
    if req.axis == 2:
        if req.requested_state == 0:
            odrv0.axis0.requested_state = AXIS_STATE_FULL_CALIBRATION_SEQUENCE
            while odrv0.axis0.current_state != AXIS_STATE_IDLE:
                time.sleep(0.1)
            odrv0.axis0.requested_state = AXIS_STATE_CLOSED_LOOP_CONTROL
        else:
            odrv0.axis0.requested_state = req.requested_state
    if req.axis == 3:
        if req.requested_state == 0:
            odrv0.axis1.requested_state = AXIS_STATE_FULL_CALIBRATION_SEQUENCE
            while odrv0.axis1.current_state != AXIS_STATE_IDLE:
                time.sleep(0.1)
            odrv0.axis1.requested_state = AXIS_STATE_CLOSED_LOOP_CONTROL
        else:
            odrv0.axis1.requested_state = req.requested_state
    if req.axis == 4:
        if req.requested_state == 0:
            odrv2.axis0.requested_state = AXIS_STATE_FULL_CALIBRATION_SEQUENCE
            while odrv2.axis0.current_state != AXIS_STATE_IDLE:
                time.sleep(0.1)
            odrv2.axis0.requested_state = AXIS_STATE_CLOSED_LOOP_CONTROL
        else:
            odrv2.axis0.requested_state = req.requested_state
    if req.axis == 5:
        if req.requested_state == 0:
            odrv2.axis1.requested_state = AXIS_STATE_FULL_CALIBRATION_SEQUENCE
            while odrv2.axis1.current_state != AXIS_STATE_IDLE:
                time.sleep(0.1)
            odrv2.axis1.requested_state = AXIS_STATE_CLOSED_LOOP_CONTROL
        else:
            odrv2.axis1.requested_state = req.requested_state
    if req.axis == 6:
        if req.requested_state == 0:
            odrv1.axis1.requested_state = AXIS_STATE_FULL_CALIBRATION_SEQUENCE
            while odrv1.axis1.current_state != AXIS_STATE_IDLE:
                time.sleep(0.1)
            odrv1.axis1.requested_state = AXIS_STATE_CLOSED_LOOP_CONTROL
        else:
            odrv1.axis1.requested_state = req.requested_state

    return requested_stateResponse(True)


rospy.init_node('driver')

driver = rospy.Service('drive_axis', driver, drive_axis)
velocity = rospy.Service('axis_velocity', velocity, axis_velocity)
feedback = rospy.Service('axis_position', feedback, axis_position)
requested_state = rospy.Service('axis_requested_state', requested_state, axis_requested_state)

rospy.spin()
